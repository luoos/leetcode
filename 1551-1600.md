## [1562. Find Latest Group of Size M - Medium](https://leetcode.com/problems/find-latest-group-of-size-m/)

```python
import collections

class Solution:
  def findLatestStep(self, arr: List[int], m: int) -> int:
    n = len(arr)
    memo = [0] * (n + 2)
    cnt = collections.defaultdict(int)
    ans = -1
    for i, a in enumerate(arr):
      left_len, right_len = memo[a-1], memo[a+1]
      memo[a-left_len] = memo[a+right_len] = memo[a] = left_len + right_len + 1
      cnt[memo[a]] += 1
      cnt[left_len] -= 1
      cnt[right_len] -= 1
      if cnt[m]:
        ans = i + 1
    return ans
```

## [1560. Most Visited Sector in a Circular Track - Easy](https://leetcode.com/problems/most-visited-sector-in-a-circular-track/)

- only the first element and the last element matters

```python
class Solution:
  def mostVisited(self, n: int, rounds: List[int]) -> List[int]:
    fr, to = rounds[0], rounds[-1]
    if to >= fr:
      ans = list(range(fr, to+1))
    else:
      ans = list(range(1, to+1)) + list(range(fr, n+1))
    return ans
```

## [1566. Detect Pattern of Length M Repeated K or More Times - Easy](https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/)

```python
class Solution:
  def containsPattern(self, arr: List[int], m: int, k: int) -> bool:
    for i in range(len(arr) - m*k + 1):
      p = arr[i:i+m]
      if p * k == arr[i:i+m*k]:
        return True
    return False
```

## [1567. Maximum Length of Subarray With Positive Product - Medium](https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/)

```python
class Solution:
  def getMaxLen(self, nums: List[int]) -> int:
    max_len, start, is_positive, first_minus_index = 0, 0, True, -1
    for i, n in enumerate(nums):
      if n == 0:
        start, is_positive, first_minus_index = i + 1, True, -1
      else:
        if n > 0:
          if max_len == 0:
            max_len = 1
        else:
          is_positive = not is_positive
          if first_minus_index == -1:
            first_minus_index = i
        if is_positive:
          max_len = max(max_len, i - start + 1)
        elif first_minus_index != -1:
          max_len = max(max_len, i-first_minus_index)
    return max_len
```

## [1568. Minimum Number of Days to Disconnect Island - Medium](https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/)

- The answer is at most 2

```python
from copy import deepcopy

class Solution:
  def minDays(self, grid: List[List[int]]) -> int:
    if countIsland(deepcopy(grid)) != 1:
      return 0

    R, C = len(grid), len(grid[0])
    for r in range(R):
      for c in range(C):
        if grid[r][c] == 1:
          copied = deepcopy(grid)
          copied[r][c] = 0
          if countIsland(copied) > 1:
            return 1

    return 2


def countIsland(grid: List[List[int]]) -> int:
  R, C = len(grid), len(grid[0])
  def expand(r, c):
    if r < 0 or c < 0 or r == R or c == C or grid[r][c] == 0:
      return
    grid[r][c] = 0
    expand(r+1, c); expand(r-1, c)
    expand(r, c+1); expand(r, c-1)

  cnt = 0
  for r in range(R):
    for c in range(C):
      if grid[r][c] == 1:
        cnt += 1
        expand(r, c)
  return cnt
```

## [1569. Number of Ways to Reorder Array to Get Same BST - Hard](https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/)

```python
from math import comb

class Solution:
  def numOfWays(self, nums: List[int]) -> int:
    M = 10**9 + 7
    def f(l):
      if len(l) <= 2:
        return 1
      head = l[0]
      left = [n for n in l[1:] if n < head]
      right = [n for n in l[1:] if n > head]
      return (comb(len(left)+len(right), len(left)) * f(left) * f(right)) % M
    return f(nums) - 1
```
