## [1562. Find Latest Group of Size M - Medium](https://leetcode.com/problems/find-latest-group-of-size-m/)

```python
import collections

class Solution:
  def findLatestStep(self, arr: List[int], m: int) -> int:
    n = len(arr)
    memo = [0] * (n + 2)
    cnt = collections.defaultdict(int)
    ans = -1
    for i, a in enumerate(arr):
      left_len, right_len = memo[a-1], memo[a+1]
      memo[a-left_len] = memo[a+right_len] = memo[a] = left_len + right_len + 1
      cnt[memo[a]] += 1
      cnt[left_len] -= 1
      cnt[right_len] -= 1
      if cnt[m]:
        ans = i + 1
    return ans
```

## [1560. Most Visited Sector in a Circular Track - Easy](https://leetcode.com/problems/most-visited-sector-in-a-circular-track/)

- only the first element and the last element matters

```python
class Solution:
  def mostVisited(self, n: int, rounds: List[int]) -> List[int]:
    fr, to = rounds[0], rounds[-1]
    if to >= fr:
      ans = list(range(fr, to+1))
    else:
      ans = list(range(1, to+1)) + list(range(fr, n+1))
    return ans
```

## [1566. Detect Pattern of Length M Repeated K or More Times - Easy](https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/)

```python
class Solution:
  def containsPattern(self, arr: List[int], m: int, k: int) -> bool:
    for i in range(len(arr) - m*k + 1):
      p = arr[i:i+m]
      if p * k == arr[i:i+m*k]:
        return True
    return False
```

## [1567. Maximum Length of Subarray With Positive Product - Medium](https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/)

```python
class Solution:
  def getMaxLen(self, nums: List[int]) -> int:
    max_len, start, is_positive, first_minus_index = 0, 0, True, -1
    for i, n in enumerate(nums):
      if n == 0:
        start, is_positive, first_minus_index = i + 1, True, -1
      else:
        if n > 0:
          if max_len == 0:
            max_len = 1
        else:
          is_positive = not is_positive
          if first_minus_index == -1:
            first_minus_index = i
        if is_positive:
          max_len = max(max_len, i - start + 1)
        elif first_minus_index != -1:
          max_len = max(max_len, i-first_minus_index)
    return max_len
```

## [1568. Minimum Number of Days to Disconnect Island - Medium](https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/)

- The answer is at most 2

```python
from copy import deepcopy

class Solution:
  def minDays(self, grid: List[List[int]]) -> int:
    if countIsland(deepcopy(grid)) != 1:
      return 0

    R, C = len(grid), len(grid[0])
    for r in range(R):
      for c in range(C):
        if grid[r][c] == 1:
          copied = deepcopy(grid)
          copied[r][c] = 0
          if countIsland(copied) > 1:
            return 1

    return 2


def countIsland(grid: List[List[int]]) -> int:
  R, C = len(grid), len(grid[0])
  def expand(r, c):
    if r < 0 or c < 0 or r == R or c == C or grid[r][c] == 0:
      return
    grid[r][c] = 0
    expand(r+1, c); expand(r-1, c)
    expand(r, c+1); expand(r, c-1)

  cnt = 0
  for r in range(R):
    for c in range(C):
      if grid[r][c] == 1:
        cnt += 1
        expand(r, c)
  return cnt
```

## [1569. Number of Ways to Reorder Array to Get Same BST - Hard](https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/)

```python
from math import comb

class Solution:
  def numOfWays(self, nums: List[int]) -> int:
    M = 10**9 + 7
    def f(l):
      if len(l) <= 2:
        return 1
      head = l[0]
      left = [n for n in l[1:] if n < head]
      right = [n for n in l[1:] if n > head]
      return (comb(len(left)+len(right), len(left)) * f(left) * f(right)) % M
    return f(nums) - 1
```

## [1576. Replace All ?'s to Avoid Consecutive Repeating Characters - Easy](https://leetcode.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/)

- Check head and tail with `or`

```python
class Solution:
  def modifyString(self, s: str) -> str:
    s = list(s)
    for i, c in enumerate(s):
      if c == '?':
        for p in 'abc':
          if (i == 0 or s[i-1] != p) and (i == len(s)-1 or s[i+1] != p):
            s[i] = p
            break
    return ''.join(s)
```

## [1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers - Medium](https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/)

```python
from collections import Counter

class Solution:
  def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
    def helper(count1, count2):
      res = 0
      for n1, cnt1 in count1.items():
        sqr = n1*n1
        used = set()
        for n2, cnt2 in count2.items():
          if n2 * n2 == sqr:
            res += cnt1 * ((cnt2 * (cnt2 - 1)) // 2)
          else:
            other = sqr / n2
            if other in count2 and other not in used:
              res += cnt1 * cnt2 * count2[other]
          used.add(n2)
      return res

    counter1 = Counter(nums1); counter2 = Counter(nums2)
    return helper(counter1, counter2) + helper(counter2, counter1)
```

## [1578. Minimum Deletion Cost to Avoid Repeating Letters - Medium](https://leetcode.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/)

```python
# greedy
class Solution:
  def minCost(self, s: str, cost: List[int]) -> int:
    ans, last_c, last_cost = 0, s[0], cost[0]
    for i, c in enumerate(s[1:], 1):
      if c == last_c:
        ans += min(cost[i], last_cost)
        last_cost = max(cost[i], last_cost)
      else:
        last_c, last_cost = c, cost[i]
    return ans
```

## [1579. Remove Max Number of Edges to Keep Graph Fully Traversable - Hard](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/)

```python
class Solution:
  def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
    def union(m, n, arr):
      if m > n: m, n = n, m
      m, n = find(m, arr), find(n, arr)
      if m == n: return False
      arr[n] = m
      return True

    def find(m, arr):
      if m != arr[m]:
        arr[m] = find(arr[m], arr)
      return arr[m]

    arr = list(range(n+1))
    ab = [0, 0, 0]  # connected nodes for alice and bob. ab[0] is redundant
    ans = 0  # cnt of redundant edges
    for ty, i, j in edges:
      if ty == 3:
        if union(i, j, arr):
          ab[1] += 1; ab[2] += 1
        else:
          ans += 1

    arrs = [0, arr, arr[:]]
    for ty, i, j in edges:
      if ty == 3:
        continue
      if union(i, j, arrs[ty]):
        ab[ty] += 1
      else:
        ans += 1

    return ans if ab[1] == ab[2] == n-1 else -1
```
