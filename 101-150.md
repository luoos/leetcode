## [139. Word Break - Medium](https://leetcode.com/problems/word-break/)

```python
from collections import defaultdict
import functools

class Solution:
  def wordBreak(self, s: str, wordDict: List[str]) -> bool:
    # DFS with memorization

    # Check if wordDict contains all necessary chars
    s1 = set(s)
    # s2 = set()
    # for w in wordDict:
    #   s2 |= set(w)
    s2 = functools.reduce(lambda r, w: r | set(w), wordDict, set())
    if s1 - s2:
      return False

    dic = defaultdict(list)
    wordDict.sort(key=lambda x: len(x), reverse=True)
    for word in wordDict:
      dic[word[0]].append(word)

    can_continue_with_index = [True] * len(s)
    def dfs(target, i):
      if not target:
        return True
      if not can_continue_with_index[i]:
        return False
      words = dic[target[0]]
      for w in words:
        if target.startswith(w) and dfs(target[len(w):], i + len(w)):
          return True
      can_continue_with_index[i] = False
      return False

    return dfs(s, 0)



class Solution:
  def wordBreak(self, s: str, wordDict: List[str]) -> bool:
    # Check if wordDict contains all necessary chars
    s1 = set(s)
    s2 = functools.reduce(lambda r, w: r | set(w), wordDict, set())
    if s1 - s2:
      return False

    wordSet = set(wordDict)
    longest_word_len = max([len(w) for w in wordDict])

    can_continue_with_index = [True] * len(s)  # index of s
    s_len = len(s)
    def dfs(s, idx):
      if idx == s_len:
        return True
      if not can_continue_with_index[idx]:
        return False
      for i in range(1, longest_word_len+1):
        if s[idx:idx+i] in wordSet and dfs(s, idx+i):
          return True
      can_continue_with_index[idx] = False  # s[i:] is impossible to construct
      return False

    return dfs(s, 0)
```