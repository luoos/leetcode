## [139. Word Break - Medium](https://leetcode.com/problems/word-break/)

```python
from collections import defaultdict
import functools

class Solution:
  def wordBreak(self, s: str, wordDict: List[str]) -> bool:
    # DFS with memorization

    # Check if wordDict contains all necessary chars
    s1 = set(s)
    # s2 = set()
    # for w in wordDict:
    #   s2 |= set(w)
    s2 = functools.reduce(lambda r, w: r | set(w), wordDict, set())
    if s1 - s2:
      return False

    dic = defaultdict(list)
    wordDict.sort(key=lambda x: len(x), reverse=True)
    for word in wordDict:
      dic[word[0]].append(word)

    can_continue_with_index = [True] * len(s)
    def dfs(target, i):
      if not target:
        return True
      if not can_continue_with_index[i]:
        return False
      words = dic[target[0]]
      for w in words:
        if target.startswith(w) and dfs(target[len(w):], i + len(w)):
          return True
      can_continue_with_index[i] = False
      return False

    return dfs(s, 0)
```


```python
class Solution:
  def wordBreak(self, s: str, wordDict: List[str]) -> bool:
    # Check if wordDict contains all necessary chars
    s1 = set(s)
    s2 = functools.reduce(lambda r, w: r | set(w), wordDict, set())
    if s1 - s2:
      return False

    wordSet = set(wordDict)
    longest_word_len = max([len(w) for w in wordDict])

    can_continue_with_index = [True] * len(s)  # index of s
    s_len = len(s)
    def dfs(s, idx):
      if idx == s_len:
        return True
      if not can_continue_with_index[idx]:
        return False
      for i in range(1, longest_word_len+1):
        if s[idx:idx+i] in wordSet and dfs(s, idx+i):
          return True
      can_continue_with_index[idx] = False  # s[i:] is impossible to construct
      return False

    return dfs(s, 0)
```

## [143. Reorder List - Medium](https://leetcode.com/problems/reorder-list/)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
  def reorderList(self, head: ListNode) -> None:
    """
    Do not return anything, modify head in-place instead.
    """
    # slow and fast pointer to get two parts
    if not head:
      return
    slow = fast = head
    while fast and fast.next:
      slow = slow.next
      fast = fast.next.next

    # reverse latter part
    pre, cur = None, slow.next
    while cur:
      pre, cur.next, cur = cur, pre, cur.next

    slow.next = None
    # needle
    first, second = head, pre
    while first and second:
      second.next, first.next, first, second = first.next, second, first.next, second.next
```