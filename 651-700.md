## [659. Split Array into Consecutive Subsequences - Medium](https://leetcode.com/problems/split-array-into-consecutive-subsequences/)

```python
from collections import Counter

class Solution:
  def isPossible(self, nums: List[int]) -> bool:
    counter = Counter(nums)
    end = Counter()
    for n in nums:
      if counter[n] > 0:
        if end[n-1] > 0:
          end[n-1] -= 1; end[n] += 1
        elif counter[n+1] > 0 and counter[n+2] > 0:
          counter[n+1] -= 1; counter[n+2] -= 1
          end[n+2] += 1
        else:
          return False
        counter[n] -= 1
    return True
```

## [692. Top K Frequent Words - Medium](https://leetcode.com/problems/top-k-frequent-words/)

```python
import collections

class Solution:
  def topKFrequent(self, words: List[str], k: int) -> List[str]:
      counter = collections.Counter(words)
      h = list(counter.items())
      h.sort(key=lambda item: (-item[1], item[0]))
      ans = [item[0] for item in h[:k]]
      return ans
```

```python
import collections
import heapq

class Solution(object):
  def topKFrequent(self, words, k):
    counter = collections.Counter(words)

    h = []
    for word, cnt in counter.items():
      heapq.heappush(h, Element(word, cnt))
      if len(h) > k:
        heapq.heappop(h)
    ans = []
    while h:
      ans.append(heapq.heappop(h).word)
    return ans[::-1]


class Element(object):
  def __init__(self, word, cnt):
    self.word = word
    self.cnt = cnt

  def __lt__(self, other):
    if self.cnt == other.cnt:
      return self.word > other.word
    return self.cnt < other.cnt

  def __eq__(self, other):
    return self.word == other.word
```