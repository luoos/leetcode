## [221. Maximal Square - Medium](https://leetcode.com/problems/maximal-square/)

```python
class Solution:
  def maximalSquare(self, matrix: List[List[str]]) -> int:
    if not matrix or not matrix[0]:
      return 0
    ROW, COL = len(matrix), len(matrix[0])
    dp = [[0] * COL for _ in range(ROW)]
    # process the first row
    dp[0] = [int(n) for n in matrix[0]]
    ans = max(dp[0])
    # process the first column
    for row in range(ROW):
      dp[row][0] = int(matrix[row][0])
      ans = max(ans, dp[row][0])

    for row in range(1, ROW):
      for col in range(1, COL):
        if matrix[row][col] == '1':
          dp[row][col] = (
              min(dp[row-1][col], dp[row][col-1], dp[row-1][col-1]) + 1
          )

          ans = max(ans, dp[row][col])
    return ans**2


# Space optimization, just use two rows
class Solution:
  def maximalSquare(self, matrix: List[List[str]]) -> int:
    if not matrix or not matrix[0]:
      return 0
    ROW, COL = len(matrix), len(matrix[0])
    dp = [[int(n) for n in matrix[0]], [0] * COL]
    print(dp)
    ans = max(dp[0])

    for row in range(1, ROW):
      for col in range(COL):
        if col == 0:
          dp[1][0] = int(matrix[row][col])
          ans = max(ans, dp[1][0])
          continue

        if matrix[row][col] == '1':
          dp[1][col] = min(dp[1][col-1], dp[0][col], dp[0][col-1]) + 1
          ans = max(ans, dp[1][col])
      dp[0] = dp[1]
      dp[1] = [0] * COL
    return ans**2
```

## [238. Product of Array Except Self - Medium](https://leetcode.com/problems/product-of-array-except-self/)

```python
import functools

class Solution:
  def productExceptSelf(self, nums: List[int]) -> List[int]:
    # [TLE] Brute force
    # Time: O(n^2)
    # Space: O(n)
    ans = [0] * len(nums)
    for i in range(len(nums)):
      ans[i] = functools.reduce(lambda x, y: x*y, nums[0:i] + nums[i+1:], 1)
    return ans



class Solution:
  def productExceptSelf(self, nums: List[int]) -> List[int]:
    # [Accept] Count "0" element. Three different situations. Use division
    # 1. More than one "0"
    # 2. Only one "0"
    # 3. No "0"
    # Time: O(n)
    # Space: O(n)
    zero_index = []
    product = 1
    ans = [0] * len(nums)
    for i, n in enumerate(nums):
      if n == 0:
        zero_index.append(i)
        if len(zero_index) == 2:
          return ans
      else:
        product *= n

    if zero_index:
      assert(len(zero_index) == 1)
      ans[zero_index[0]] = product
      return ans
    for i, n in enumerate(nums):
      ans[i] = product // n
    return ans



class Solution:
  def productExceptSelf(self, nums: List[int]) -> List[int]:
    # [Accept] Two passes
    # Time: O(n)
    # Space: O(1), [ans] doesn't count
    ans = [1] * len(nums)
    tmp = nums[0]
    for i in range(1, len(nums)):
      ans[i] *= tmp
      tmp *= nums[i]
    tmp = nums[-1]
    for i in range(len(nums)-1)[::-1]:
      ans[i] *= tmp
      tmp *= nums[i]
    return ans
```