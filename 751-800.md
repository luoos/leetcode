## [763. Partition Labels - Medium](https://leetcode.com/problems/partition-labels/)

```python
# based on 56. merge intervals
from collections import defaultdict

class Solution:
  def partitionLabels(self, S: str) -> List[int]:
    dic = defaultdict(list)
    for i, c in enumerate(S):
      if dic[c]:
        dic[c].pop()
      else:
        dic[c].append(i)
      dic[c].append(i)
    intervals = list(dic.values())
    if not intervals:
      return len(S)
    merged = self.mergeIntervals(intervals)
    ans = [e - s + 1 for s, e in merged]
    return ans

  def mergeIntervals(self, intervals):
    intervals.sort(key=lambda x: x[0])
    merge = [intervals[0]]
    for s, e in intervals[1:]:
      if s < merge[-1][1]:
        merge[-1][1] = max(merge[-1][1], e)
      else:
        merge.append([s, e])
    return merge
```

```python
# smart solution in discussion
class Solution:
  def partitionLabels(self, S: str) -> List[int]:
    dic = {c: i for i, c in enumerate(S)}
    last = start = 0
    ans = []
    for i in range(len(S)):
      last = max(last, dic[S[i]])
      if last == i:
        ans.append(i-start+1)
        start = i + 1
    return ans
```

## [785. Is Graph Bipartite? - Medium](https://leetcode.com/problems/is-graph-bipartite/)

```python
class Solution:
  def isBipartite(self, graph: List[List[int]]) -> bool:
    color_map = [-1] * len(graph)
    for i in range(len(graph)):
      if color_map[i] != -1:
        continue
      stack = [(i, 0)]
      while stack:
        i, color = stack.pop()
        other_color = color^1
        for neigh in graph[i]:
          if color_map[neigh] == -1:
            stack.append((neigh, other_color))
            color_map[neigh] = other_color
          elif color_map[neigh] == color:
            return False
    return True
```
