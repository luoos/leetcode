## [763. Partition Labels - Medium](https://leetcode.com/problems/partition-labels/)

```python
# based on 56. merge intervals
from collections import defaultdict

class Solution:
  def partitionLabels(self, S: str) -> List[int]:
    dic = defaultdict(list)
    for i, c in enumerate(S):
      if dic[c]:
        dic[c].pop()
      else:
        dic[c].append(i)
      dic[c].append(i)
    intervals = list(dic.values())
    if not intervals:
      return len(S)
    merged = self.mergeIntervals(intervals)
    ans = [e - s + 1 for s, e in merged]
    return ans

  def mergeIntervals(self, intervals):
    intervals.sort(key=lambda x: x[0])
    merge = [intervals[0]]
    for s, e in intervals[1:]:
      if s < merge[-1][1]:
        merge[-1][1] = max(merge[-1][1], e)
      else:
        merge.append([s, e])
    return merge
```

## [767. Reorganize String - Medium](https://leetcode.com/problems/reorganize-string/)

```python
from collections import Counter

import heapq

class Solution:
  def reorganizeString(self, S: str) -> str:
    counter = Counter(S)
    h = []
    for c, cnt in counter.items():
      heapq.heappush(h, [-cnt, c])

    slots = [''] * len(S)
    cnt, c = heapq.heappop(h)
    if 2*(-cnt) - 1 > len(S):
      return ''
    for i in [*range(0, len(S), 2), *range(1, len(S), 2)]:
      if cnt == 0:
        cnt, c = heapq.heappop(h)
      slots[i] = c
      cnt += 1
    return ''.join(slots)
```

```python
# smart solution in discussion
class Solution:
  def partitionLabels(self, S: str) -> List[int]:
    dic = {c: i for i, c in enumerate(S)}
    last = start = 0
    ans = []
    for i in range(len(S)):
      last = max(last, dic[S[i]])
      if last == i:
        ans.append(i-start+1)
        start = i + 1
    return ans
```

## [785. Is Graph Bipartite? - Medium](https://leetcode.com/problems/is-graph-bipartite/)

```python
class Solution:
  def isBipartite(self, graph: List[List[int]]) -> bool:
    color_map = [-1] * len(graph)
    for i in range(len(graph)):
      if color_map[i] != -1:
        continue
      stack = [(i, 0)]
      while stack:
        i, color = stack.pop()
        other_color = color^1
        for neigh in graph[i]:
          if color_map[neigh] == -1:
            stack.append((neigh, other_color))
            color_map[neigh] = other_color
          elif color_map[neigh] == color:
            return False
    return True
```
