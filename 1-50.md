## [20. Valid Parentheses - Easy](https://leetcode.com/problems/valid-parentheses/)

```python
class Solution:
  mapping = {')': '(', '}': '{', ']': '['}

  def isValid(self, s: str) -> bool:
    stack = []
    for p in s:
      if p not in self.mapping:  # it's open parentheses
        stack.append(p)
      else:
        if not stack or stack.pop() != self.mapping[p]:
          return False
    return len(stack) == 0
```

## [22. Generate Parentheses - Medium](https://leetcode.com/problems/generate-parentheses/)

```python
class Solution:
  def generateParenthesis(self, n: int) -> List[str]:
    ans = []
    tmp = [0] * (2*n)  # to fill in parentheses
    target_len = 2 * n
    def helper(left, right, i):
      # left and right means the corresponding parenthese we can use
      if i == target_len:
        ans.append(''.join(tmp))
        return
      if left:
        tmp[i] = '('
        helper(left-1, right+1, i+1)
      if right:
        tmp[i] = ')'
        helper(left, right-1, i+1)
    helper(n, 0, 0)
    return ans
```

## [29. Divide Two Integers - Medium](https://leetcode.com/problems/divide-two-integers/)

```python
class Solution:
  def divide(self, dividend: int, divisor: int) -> int:
    # brute force, TLE
    symbol = -1 if dividend * divisor < 0 else 1
    dividend, divisor = abs(dividend), abs(divisor)
    ans = 0
    while dividend >= divisor:
      dividend -= divisor
      ans += 1
    return symbol * ans


class Solution:
  def divide(self, dividend: int, divisor: int) -> int:
    symbol = -1 if dividend * divisor < 0 else 1
    dividend, divisor = abs(dividend), abs(divisor)
    ans = 0

    def helper(divid, divis):
      cnt = 1
      while divis <= divid:
        divis += divis
        cnt += cnt
      return cnt // 2, divis // 2

    while dividend >= divisor:
      cnt, subtract = helper(dividend, divisor)
      ans += cnt
      dividend -= subtract
    return symbol * ans
```

## [34. Find First and Last Position of Element in Sorted Array - Medium](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

```python
import bisect

class Solution:
  def searchRange(self, nums: List[int], target: int) -> List[int]:
    if not nums:
      return [-1, -1]
    left_idx = bisect.bisect_left(nums, target)
    if left_idx >= len(nums) or nums[left_idx] != target:
      return [-1, -1]
    right_idx = bisect.bisect_right(nums, target) - 1
    return [left_idx, right_idx]


class Solution:
  def searchRange(self, nums: List[int], target: int) -> List[int]:
    ans = [-1, -1]
    if not nums:
      return ans
    lo, hi = 0, len(nums) - 1
    while lo < hi:
      mid = (lo + hi) // 2  # left bias
      if nums[mid] < target: lo = mid + 1
      else: hi = mid
    if nums[lo] != target:
      return ans
    ans[0] = lo

    hi = len(nums) - 1
    while lo < hi:
      mid = (lo + hi) // 2 + 1  # right bias
      if nums[mid] > target: hi = mid - 1
      else: lo = mid
    ans[1] = hi
    return ans
```
