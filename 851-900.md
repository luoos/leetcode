## [863. All Nodes Distance K in Binary Tree - Medium](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)

```python
import collections

class Solution:
  def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
    # use a map to track direct neighbors of each node
    neighbors = collections.defaultdict(set)

    def add_neighbor(node, parent=None):
      if not node:
        return
      if parent:
        neighbors[parent].add(node)
        neighbors[node].add(parent)
      add_neighbor(node.left, node)
      add_neighbor(node.right, node)

    add_neighbor(root)
    q = [target]
    seen = set()
    k = 0
    while q and k < K:
      next_q = []
      for node in q:
        seen.add(node)
        for neighbor in neighbors[node]:
          if neighbor not in seen:
            next_q.append(neighbor)
      q = next_q
      k += 1
    return [node.val for node in q]
```

## [886. Possible Bipartition - Medium](https://leetcode.com/problems/possible-bipartition/)

```python
from collections import defaultdict

class Solution:
  def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:
    graph = defaultdict(set)
    for fr, to in dislikes:
      graph[fr].add(to)
      graph[to].add(fr)

    color_map = [-1] * (N + 1)

    for i in range(1, N+1):
      if color_map[i] != -1:
        continue
      stack = [i]
      color_map[i] = 0
      while stack:
        cur = stack.pop()
        color = color_map[cur]
        other_color = color ^ 1
        for neigh in graph[cur]:
          if color_map[neigh] == -1:
            color_map[neigh] = other_color
            stack.append(neigh)
          elif color_map[neigh] == color:
            return False
    return True
```

## [889. Construct Binary Tree from Preorder and Postorder Traversal - Medium](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

```python
class Solution:
  def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:
    if not pre:
      return None
    root = TreeNode(post.pop())
    if len(pre) == 1:
      return root
    idx = pre.index(post[-1])
    root.right = self.constructFromPrePost(pre[idx:], post)
    root.left = self.constructFromPrePost(pre[1:idx], post)
    return root
```
